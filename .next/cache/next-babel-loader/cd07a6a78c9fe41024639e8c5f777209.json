{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { ethers } from 'ethers';\nimport { QUERY_KEYS } from 'lib/constants';\nimport { calculateExternalAwardsValue } from 'lib/services/calculateExternalAwardsValue';\nimport { compileHistoricalErc20Awards } from 'lib/services/compileHistoricalErc20Awards';\nimport { compileHistoricalErc721Awards } from 'lib/services/compileHistoricalErc721Awards'; // This gathers historical data for a pool and prize\n//\n// It uses the ERC20/721 balances pulled from the pooltogether subgraph as we want the balance\n// at the time the prize was awarded, etc (called balanceAwarded)\n\nexport const compileHistoricalPool = (chainId, poolInfo, cache, graphPool, poolAddress, blockNumber, prize) => {\n  const interestPrizeUSD = ethers.utils.bigNumberify((prize === null || prize === void 0 ? void 0 : prize.amount) || 0);\n\n  const poolObj = _objectSpread(_objectSpread({}, poolInfo), graphPool);\n\n  const uniswapPriceData = cache.getQueryData([QUERY_KEYS.uniswapTokensQuery, chainId, poolAddress, blockNumber]);\n  const externalErc20Awards = compileHistoricalErc20Awards(prize, uniswapPriceData);\n  const ethErc721Awards = cache.getQueryData([QUERY_KEYS.ethereumErc721sQuery, chainId, poolAddress, blockNumber]);\n  const externalErc721Awards = compileHistoricalErc721Awards(ethErc721Awards, prize);\n  const externalAwardsUSD = calculateExternalAwardsValue(externalErc20Awards);\n  const totalPrizeUSD = externalAwardsUSD ? interestPrizeUSD.add(ethers.utils.parseEther(externalAwardsUSD.toString())) : interestPrizeUSD;\n  return _objectSpread(_objectSpread(_objectSpread({}, poolInfo), poolObj), {}, {\n    poolAddress: poolAddress,\n    prizeAmountUSD: totalPrizeUSD,\n    interestPrizeUSD,\n    externalAwardsUSD,\n    // externalItemAwardsValue,\n    externalErc20Awards,\n    externalErc721Awards,\n    ethErc721Awards\n  });\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/services/compileHistoricalPool.jsx"],"names":["ethers","QUERY_KEYS","calculateExternalAwardsValue","compileHistoricalErc20Awards","compileHistoricalErc721Awards","compileHistoricalPool","chainId","poolInfo","cache","graphPool","poolAddress","blockNumber","prize","interestPrizeUSD","utils","bigNumberify","amount","poolObj","uniswapPriceData","getQueryData","uniswapTokensQuery","externalErc20Awards","ethErc721Awards","ethereumErc721sQuery","externalErc721Awards","externalAwardsUSD","totalPrizeUSD","add","parseEther","toString","prizeAmountUSD"],"mappings":";;;;;;AAAA,SAASA,MAAT,QAAuB,QAAvB;AAEA,SACEC,UADF,QAEO,eAFP;AAIA,SAASC,4BAAT,QAA6C,2CAA7C;AACA,SAASC,4BAAT,QAA6C,2CAA7C;AACA,SAASC,6BAAT,QAA8C,4CAA9C,C,CAEA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,qBAAqB,GAAG,CACnCC,OADmC,EAEnCC,QAFmC,EAGnCC,KAHmC,EAInCC,SAJmC,EAKnCC,WALmC,EAMnCC,WANmC,EAOnCC,KAPmC,KAQhC;AACH,QAAMC,gBAAgB,GAAGb,MAAM,CAACc,KAAP,CAAaC,YAAb,CAA0B,CAAAH,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEI,MAAP,KAAiB,CAA3C,CAAzB;;AAEA,QAAMC,OAAO,mCACRV,QADQ,GAERE,SAFQ,CAAb;;AAKA,QAAMS,gBAAgB,GAAGV,KAAK,CAACW,YAAN,CAAmB,CAC1ClB,UAAU,CAACmB,kBAD+B,EAE1Cd,OAF0C,EAG1CI,WAH0C,EAI1CC,WAJ0C,CAAnB,CAAzB;AAMA,QAAMU,mBAAmB,GAAGlB,4BAA4B,CAACS,KAAD,EAAQM,gBAAR,CAAxD;AAEA,QAAMI,eAAe,GAAGd,KAAK,CAACW,YAAN,CAAmB,CACzClB,UAAU,CAACsB,oBAD8B,EAEzCjB,OAFyC,EAGzCI,WAHyC,EAIzCC,WAJyC,CAAnB,CAAxB;AAMA,QAAMa,oBAAoB,GAAGpB,6BAA6B,CAACkB,eAAD,EAAkBV,KAAlB,CAA1D;AAEA,QAAMa,iBAAiB,GAAGvB,4BAA4B,CAACmB,mBAAD,CAAtD;AAEA,QAAMK,aAAa,GAAGD,iBAAiB,GACrCZ,gBAAgB,CAACc,GAAjB,CAAqB3B,MAAM,CAACc,KAAP,CAAac,UAAb,CACnBH,iBAAiB,CAACI,QAAlB,EADmB,CAArB,CADqC,GAIrChB,gBAJF;AAMA,uDACKN,QADL,GAEKU,OAFL;AAGEP,IAAAA,WAAW,EAAEA,WAHf;AAIEoB,IAAAA,cAAc,EAAEJ,aAJlB;AAKEb,IAAAA,gBALF;AAMEY,IAAAA,iBANF;AAOE;AACAJ,IAAAA,mBARF;AASEG,IAAAA,oBATF;AAUEF,IAAAA;AAVF;AAYD,CApDM","sourcesContent":["import { ethers } from 'ethers'\n\nimport {\n  QUERY_KEYS\n} from 'lib/constants'\n\nimport { calculateExternalAwardsValue } from 'lib/services/calculateExternalAwardsValue'\nimport { compileHistoricalErc20Awards } from 'lib/services/compileHistoricalErc20Awards'\nimport { compileHistoricalErc721Awards } from 'lib/services/compileHistoricalErc721Awards'\n\n// This gathers historical data for a pool and prize\n//\n// It uses the ERC20/721 balances pulled from the pooltogether subgraph as we want the balance\n// at the time the prize was awarded, etc (called balanceAwarded)\n\nexport const compileHistoricalPool = (\n  chainId,\n  poolInfo,\n  cache,\n  graphPool,\n  poolAddress,\n  blockNumber,\n  prize,\n) => {\n  const interestPrizeUSD = ethers.utils.bigNumberify(prize?.amount || 0)\n\n  const poolObj = {\n    ...poolInfo,\n    ...graphPool,\n  }\n\n  const uniswapPriceData = cache.getQueryData([\n    QUERY_KEYS.uniswapTokensQuery,\n    chainId,\n    poolAddress,\n    blockNumber\n  ])\n  const externalErc20Awards = compileHistoricalErc20Awards(prize, uniswapPriceData)\n\n  const ethErc721Awards = cache.getQueryData([\n    QUERY_KEYS.ethereumErc721sQuery,\n    chainId,\n    poolAddress,\n    blockNumber\n  ])\n  const externalErc721Awards = compileHistoricalErc721Awards(ethErc721Awards, prize)\n\n  const externalAwardsUSD = calculateExternalAwardsValue(externalErc20Awards)\n\n  const totalPrizeUSD = externalAwardsUSD ?\n    interestPrizeUSD.add(ethers.utils.parseEther(\n      externalAwardsUSD.toString()\n    )) :\n    interestPrizeUSD\n\n  return {\n    ...poolInfo,\n    ...poolObj,\n    poolAddress: poolAddress,\n    prizeAmountUSD: totalPrizeUSD,\n    interestPrizeUSD,\n    externalAwardsUSD,\n    // externalItemAwardsValue,\n    externalErc20Awards,\n    externalErc721Awards,\n    ethErc721Awards\n  }\n}\n"]},"metadata":{},"sourceType":"module"}