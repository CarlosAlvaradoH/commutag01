{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { find } from 'lodash'; // import { DRIP_TOKENS } from 'lib/constants'\n\nexport const extractPoolRewardsFromUserDrips = ({\n  poolAddresses,\n  dynamicPlayerDrips\n}) => {\n  const dripTokens = (dynamicPlayerDrips === null || dynamicPlayerDrips === void 0 ? void 0 : dynamicPlayerDrips.dripTokens) || [];\n  const balanceDrips = [];\n  const volumeDrips = []; // const balanceDrips = dynamicPlayerDrips?.balanceDrips.filter(drip => {\n  //   return poolAddresses.includes(drip.balanceDrip.prizePool.id)\n  // })\n  // const volumeDrips = dynamicPlayerDrips?.volumeDrips.filter(drip => {\n  //   return poolAddresses.includes(drip.volumeDrip.prizePool.id)\n  // })\n\n  const playerRewards = {\n    allDrips: [],\n    balance: [],\n    volume: [],\n    refVolume: []\n  };\n  dripTokens.forEach(drip => {\n    const [comptroller, dripToken, player] = drip.id.split('-');\n    const dripTokenData = {\n      name: 'Unknown',\n      symbol: 'UNK'\n    }; // const dripTokenData = DRIP_TOKENS[dripToken] || {name: 'Unknown', symbol: 'UNK'}\n\n    let finalDripData = _objectSpread({\n      dripToken: {\n        address: dripToken,\n        name: dripTokenData.name,\n        symbol: dripTokenData.symbol\n      }\n    }, drip); // Balance Drips\n\n\n    const balDrip = find(balanceDrips, bd => bd.balanceDrip.dripToken === dripToken);\n\n    if (balDrip) {\n      finalDripData = _objectSpread(_objectSpread({}, finalDripData), balDrip);\n      playerRewards.balance.push(_objectSpread({}, finalDripData));\n    } // Volume Drips\n\n\n    const volDrip = find(volumeDrips, vd => vd.volumeDrip.dripToken === dripToken);\n\n    if (volDrip) {\n      finalDripData = _objectSpread(_objectSpread({}, finalDripData), volDrip);\n\n      if (volDrip.volumeDrip.referral) {\n        playerRewards.refVolume.push(_objectSpread({}, finalDripData));\n      } else {\n        playerRewards.volume.push(_objectSpread({}, finalDripData));\n      }\n    }\n\n    playerRewards.allDrips.push(_objectSpread({}, finalDripData));\n  });\n  return playerRewards;\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/utils/extractPoolRewardsFromUserDrips.js"],"names":["find","extractPoolRewardsFromUserDrips","poolAddresses","dynamicPlayerDrips","dripTokens","balanceDrips","volumeDrips","playerRewards","allDrips","balance","volume","refVolume","forEach","drip","comptroller","dripToken","player","id","split","dripTokenData","name","symbol","finalDripData","address","balDrip","bd","balanceDrip","push","volDrip","vd","volumeDrip","referral"],"mappings":";;;;;;AAAA,SAASA,IAAT,QAAqB,QAArB,C,CAEA;;AAEA,OAAO,MAAMC,+BAA+B,GAAG,CAAC;AAAEC,EAAAA,aAAF;AAAiBC,EAAAA;AAAjB,CAAD,KAA2C;AACxF,QAAMC,UAAU,GAAG,CAAAD,kBAAkB,SAAlB,IAAAA,kBAAkB,WAAlB,YAAAA,kBAAkB,CAAEC,UAApB,KAAkC,EAArD;AAEA,QAAMC,YAAY,GAAG,EAArB;AACA,QAAMC,WAAW,GAAG,EAApB,CAJwF,CAMxF;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAMC,aAAa,GAAG;AACpBC,IAAAA,QAAQ,EAAE,EADU;AAEpBC,IAAAA,OAAO,EAAE,EAFW;AAGpBC,IAAAA,MAAM,EAAE,EAHY;AAIpBC,IAAAA,SAAS,EAAE;AAJS,GAAtB;AAOAP,EAAAA,UAAU,CAACQ,OAAX,CAAmBC,IAAI,IAAI;AACzB,UAAM,CAACC,WAAD,EAAcC,SAAd,EAAyBC,MAAzB,IAAmCH,IAAI,CAACI,EAAL,CAAQC,KAAR,CAAc,GAAd,CAAzC;AACA,UAAMC,aAAa,GAAG;AAAEC,MAAAA,IAAI,EAAE,SAAR;AAAmBC,MAAAA,MAAM,EAAE;AAA3B,KAAtB,CAFyB,CAGzB;;AACA,QAAIC,aAAa;AACfP,MAAAA,SAAS,EAAE;AACTQ,QAAAA,OAAO,EAAER,SADA;AAETK,QAAAA,IAAI,EAAED,aAAa,CAACC,IAFX;AAGTC,QAAAA,MAAM,EAAEF,aAAa,CAACE;AAHb;AADI,OAMZR,IANY,CAAjB,CAJyB,CAazB;;;AACA,UAAMW,OAAO,GAAGxB,IAAI,CAACK,YAAD,EAAeoB,EAAE,IAAIA,EAAE,CAACC,WAAH,CAAeX,SAAf,KAA6BA,SAAlD,CAApB;;AACA,QAAIS,OAAJ,EAAa;AACXF,MAAAA,aAAa,mCACRA,aADQ,GAERE,OAFQ,CAAb;AAIAjB,MAAAA,aAAa,CAACE,OAAd,CAAsBkB,IAAtB,mBAA+BL,aAA/B;AACD,KArBwB,CAuBzB;;;AACA,UAAMM,OAAO,GAAG5B,IAAI,CAACM,WAAD,EAAcuB,EAAE,IAAIA,EAAE,CAACC,UAAH,CAAcf,SAAd,KAA4BA,SAAhD,CAApB;;AACA,QAAIa,OAAJ,EAAa;AACXN,MAAAA,aAAa,mCACRA,aADQ,GAERM,OAFQ,CAAb;;AAIA,UAAIA,OAAO,CAACE,UAAR,CAAmBC,QAAvB,EAAiC;AAC/BxB,QAAAA,aAAa,CAACI,SAAd,CAAwBgB,IAAxB,mBAAiCL,aAAjC;AACD,OAFD,MAEO;AACLf,QAAAA,aAAa,CAACG,MAAd,CAAqBiB,IAArB,mBAA8BL,aAA9B;AACD;AACF;;AAEDf,IAAAA,aAAa,CAACC,QAAd,CAAuBmB,IAAvB,mBAAgCL,aAAhC;AACD,GAtCD;AAwCA,SAAOf,aAAP;AACD,CA7DM","sourcesContent":["import { find } from 'lodash'\n\n// import { DRIP_TOKENS } from 'lib/constants'\n\nexport const extractPoolRewardsFromUserDrips = ({ poolAddresses, dynamicPlayerDrips }) => {\n  const dripTokens = dynamicPlayerDrips?.dripTokens || []\n\n  const balanceDrips = []\n  const volumeDrips = []\n\n  // const balanceDrips = dynamicPlayerDrips?.balanceDrips.filter(drip => {\n  //   return poolAddresses.includes(drip.balanceDrip.prizePool.id)\n  // })\n  // const volumeDrips = dynamicPlayerDrips?.volumeDrips.filter(drip => {\n  //   return poolAddresses.includes(drip.volumeDrip.prizePool.id)\n  // })\n\n  const playerRewards = {\n    allDrips: [],\n    balance: [],\n    volume: [],\n    refVolume: []\n  }\n\n  dripTokens.forEach(drip => {\n    const [comptroller, dripToken, player] = drip.id.split('-')\n    const dripTokenData = { name: 'Unknown', symbol: 'UNK' }\n    // const dripTokenData = DRIP_TOKENS[dripToken] || {name: 'Unknown', symbol: 'UNK'}\n    let finalDripData = {\n      dripToken: {\n        address: dripToken,\n        name: dripTokenData.name,\n        symbol: dripTokenData.symbol,\n      },\n      ...drip,\n    }\n\n    // Balance Drips\n    const balDrip = find(balanceDrips, bd => bd.balanceDrip.dripToken === dripToken)\n    if (balDrip) {\n      finalDripData = {\n        ...finalDripData,\n        ...balDrip\n      }\n      playerRewards.balance.push({...finalDripData})\n    }\n\n    // Volume Drips\n    const volDrip = find(volumeDrips, vd => vd.volumeDrip.dripToken === dripToken)\n    if (volDrip) {\n      finalDripData = {\n        ...finalDripData,\n        ...volDrip\n      }\n      if (volDrip.volumeDrip.referral) {\n        playerRewards.refVolume.push({...finalDripData})\n      } else {\n        playerRewards.volume.push({...finalDripData})\n      }\n    }\n\n    playerRewards.allDrips.push({...finalDripData})\n  })\n\n  return playerRewards\n}"]},"metadata":{},"sourceType":"module"}