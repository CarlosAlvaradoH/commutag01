{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nvar _s = $RefreshSig$();\n\nimport { useContext } from 'react';\nimport { useQuery } from 'react-query';\nimport { ethers } from 'ethers';\nimport { CONTRACT_ADDRESSES, MAINNET_POLLING_INTERVAL, QUERY_KEYS } from 'lib/constants';\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider';\nimport { fetchExternalLootBoxData } from 'lib/utils/fetchExternalLootBoxData';\nimport { getCurrentLootBox } from 'lib/utils/getCurrentLootBox';\nexport function useEthereumLootBoxQuery(pool) {\n  _s();\n\n  var _CONTRACT_ADDRESSES$c, _erc, _erc$tokenIds;\n\n  var _useContext = useContext(AuthControllerContext),\n      chainId = _useContext.chainId,\n      pauseQueries = _useContext.pauseQueries,\n      provider = _useContext.provider;\n\n  var lootBoxControllerAddress = (_CONTRACT_ADDRESSES$c = CONTRACT_ADDRESSES[chainId]) === null || _CONTRACT_ADDRESSES$c === void 0 ? void 0 : _CONTRACT_ADDRESSES$c.LootBoxController;\n\n  var _getCurrentLootBox = getCurrentLootBox(pool),\n      lootBoxAddress = _getCurrentLootBox.lootBoxAddress,\n      tokenId = _getCurrentLootBox.tokenId;\n\n  tokenId = ethers.utils.bigNumberify((_erc = erc721) === null || _erc === void 0 ? void 0 : (_erc$tokenIds = _erc.tokenIds) === null || _erc$tokenIds === void 0 ? void 0 : _erc$tokenIds[0]);\n  var enabled = !pauseQueries && chainId && Boolean(lootBoxControllerAddress) && Boolean(tokenId);\n  return useQuery([QUERY_KEYS.ethereumLootBoxQuery, chainId, lootBoxControllerAddress, lootBoxAddress, tokenId.toString(), -1], /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetchExternalLootBoxData(provider, lootBoxControllerAddress, lootBoxAddress, tokenId);\n\n          case 2:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), {\n    enabled: enabled,\n    refetchInterval: MAINNET_POLLING_INTERVAL\n  });\n}\n\n_s(useEthereumLootBoxQuery, \"iK6nysCWVzFwqNGlKi6I5toQ/DE=\", false, function () {\n  return [useQuery];\n});","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/hooks/useEthereumLootBoxQuery.js"],"names":["useContext","useQuery","ethers","CONTRACT_ADDRESSES","MAINNET_POLLING_INTERVAL","QUERY_KEYS","AuthControllerContext","fetchExternalLootBoxData","getCurrentLootBox","useEthereumLootBoxQuery","pool","chainId","pauseQueries","provider","lootBoxControllerAddress","LootBoxController","lootBoxAddress","tokenId","utils","bigNumberify","erc721","tokenIds","enabled","Boolean","ethereumLootBoxQuery","toString","refetchInterval"],"mappings":";;;;;AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,SAASC,QAAT,QAAyB,aAAzB;AACA,SAASC,MAAT,QAAuB,QAAvB;AAEA,SACEC,kBADF,EAEEC,wBAFF,EAGEC,UAHF,QAIO,eAJP;AAKA,SAASC,qBAAT,QAAsC,+DAAtC;AACA,SAASC,wBAAT,QAAyC,oCAAzC;AACA,SAASC,iBAAT,QAAkC,6BAAlC;AAEA,OAAO,SAASC,uBAAT,CAAiCC,IAAjC,EAAuC;AAAA;;AAAA;;AAAA,oBACAV,UAAU,CAACM,qBAAD,CADV;AAAA,MACpCK,OADoC,eACpCA,OADoC;AAAA,MAC3BC,YAD2B,eAC3BA,YAD2B;AAAA,MACbC,QADa,eACbA,QADa;;AAG5C,MAAMC,wBAAwB,4BAAGX,kBAAkB,CAACQ,OAAD,CAArB,0DAAG,sBAA6BI,iBAA9D;;AAH4C,2BAKVP,iBAAiB,CAACE,IAAD,CALP;AAAA,MAKtCM,cALsC,sBAKtCA,cALsC;AAAA,MAKtBC,OALsB,sBAKtBA,OALsB;;AAO5CA,EAAAA,OAAO,GAAGf,MAAM,CAACgB,KAAP,CAAaC,YAAb,SAA0BC,MAA1B,0DAA0B,KAAQC,QAAlC,kDAA0B,cAAmB,CAAnB,CAA1B,CAAV;AAEA,MAAMC,OAAO,GAAG,CAACV,YAAD,IACdD,OADc,IAEdY,OAAO,CAACT,wBAAD,CAFO,IAGdS,OAAO,CAACN,OAAD,CAHT;AAKA,SAAOhB,QAAQ,CACb,CAACI,UAAU,CAACmB,oBAAZ,EAAkCb,OAAlC,EAA2CG,wBAA3C,EAAqEE,cAArE,EAAqFC,OAAO,CAACQ,QAAR,EAArF,EAAyG,CAAC,CAA1G,CADa,wEAEb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkBlB,wBAAwB,CAACM,QAAD,EAAWC,wBAAX,EAAqCE,cAArC,EAAqDC,OAArD,CAA1C;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAFa,IAGb;AACEK,IAAAA,OAAO,EAAPA,OADF;AAEEI,IAAAA,eAAe,EAAEtB;AAFnB,GAHa,CAAf;AAQD;;GAtBeK,uB;UAcPR,Q","sourcesContent":["import { useContext } from 'react'\nimport { useQuery } from 'react-query'\nimport { ethers } from 'ethers'\n\nimport {\n  CONTRACT_ADDRESSES,\n  MAINNET_POLLING_INTERVAL,\n  QUERY_KEYS,\n} from 'lib/constants'\nimport { AuthControllerContext } from 'lib/components/contextProviders/AuthControllerContextProvider'\nimport { fetchExternalLootBoxData } from 'lib/utils/fetchExternalLootBoxData'\nimport { getCurrentLootBox } from 'lib/utils/getCurrentLootBox'\n\nexport function useEthereumLootBoxQuery(pool) {\n  const { chainId, pauseQueries, provider } = useContext(AuthControllerContext)\n\n  const lootBoxControllerAddress = CONTRACT_ADDRESSES[chainId]?.LootBoxController\n\n  let { lootBoxAddress, tokenId } = getCurrentLootBox(pool)\n\n  tokenId = ethers.utils.bigNumberify(erc721?.tokenIds?.[0])\n\n  const enabled = !pauseQueries &&\n    chainId &&\n    Boolean(lootBoxControllerAddress) &&\n    Boolean(tokenId)\n\n  return useQuery(\n    [QUERY_KEYS.ethereumLootBoxQuery, chainId, lootBoxControllerAddress, lootBoxAddress, tokenId.toString(), -1],\n    async () => await fetchExternalLootBoxData(provider, lootBoxControllerAddress, lootBoxAddress, tokenId),\n    {\n      enabled,\n      refetchInterval: MAINNET_POLLING_INTERVAL\n    }\n  )\n}\n"]},"metadata":{},"sourceType":"module"}