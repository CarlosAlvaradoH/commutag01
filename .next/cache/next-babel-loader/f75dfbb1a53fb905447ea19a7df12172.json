{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { isEmpty } from 'lodash';\nexport const compileHistoricalErc721Awards = (ethereumErc721Awards, prize) => {\n  const erc721GraphData = prize === null || prize === void 0 ? void 0 : prize.awardedExternalErc721Nfts;\n\n  if (isEmpty(erc721GraphData) || isEmpty(ethereumErc721Awards)) {\n    return {};\n  }\n\n  let data = {};\n  erc721GraphData.forEach(obj => {\n    // const value = priceUSD && parseFloat(balanceFormatted) * priceUSD\n    const ethereumErc721Token = ethereumErc721Awards[obj.address];\n    data[obj.address] = _objectSpread(_objectSpread({}, ethereumErc721Token), obj);\n  });\n  return data;\n};","map":{"version":3,"sources":["/Users/chuckbergeron/Git/crypto/pool-together/pool-app/lib/services/compileHistoricalErc721Awards.jsx"],"names":["isEmpty","compileHistoricalErc721Awards","ethereumErc721Awards","prize","erc721GraphData","awardedExternalErc721Nfts","data","forEach","obj","ethereumErc721Token","address"],"mappings":";;;;;;AAAA,SAASA,OAAT,QAAwB,QAAxB;AAEA,OAAO,MAAMC,6BAA6B,GAAG,CAACC,oBAAD,EAAuBC,KAAvB,KAAiC;AAC5E,QAAMC,eAAe,GAAGD,KAAH,aAAGA,KAAH,uBAAGA,KAAK,CAAEE,yBAA/B;;AAEA,MACEL,OAAO,CAACI,eAAD,CAAP,IACAJ,OAAO,CAACE,oBAAD,CAFT,EAGE;AACA,WAAO,EAAP;AACD;;AAED,MAAII,IAAI,GAAG,EAAX;AAEAF,EAAAA,eAAe,CAACG,OAAhB,CAAwBC,GAAG,IAAI;AAC7B;AACA,UAAMC,mBAAmB,GAAGP,oBAAoB,CAACM,GAAG,CAACE,OAAL,CAAhD;AAEAJ,IAAAA,IAAI,CAACE,GAAG,CAACE,OAAL,CAAJ,mCACKD,mBADL,GAEKD,GAFL;AAID,GARD;AAUA,SAAOF,IAAP;AACD,CAvBM","sourcesContent":["import { isEmpty } from 'lodash'\n\nexport const compileHistoricalErc721Awards = (ethereumErc721Awards, prize) => {\n  const erc721GraphData = prize?.awardedExternalErc721Nfts\n\n  if (\n    isEmpty(erc721GraphData) ||\n    isEmpty(ethereumErc721Awards)\n  ) {\n    return {}\n  }\n\n  let data = {}\n\n  erc721GraphData.forEach(obj => {\n    // const value = priceUSD && parseFloat(balanceFormatted) * priceUSD\n    const ethereumErc721Token = ethereumErc721Awards[obj.address]\n\n    data[obj.address] = {\n      ...ethereumErc721Token,\n      ...obj,\n    }\n  })\n\n  return data\n}\n"]},"metadata":{},"sourceType":"module"}